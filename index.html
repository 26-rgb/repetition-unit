<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GLBãƒ¢ãƒ‡ãƒ«å›è»¢ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</title>
<style>
  body { margin: 0; overflow: hidden; }
  #ui {
    position: absolute;
    bottom: 5px;
    left: 5px;
    padding: 12px;
    font-size: 16px;
    background: rgba(255, 255, 255, 0.9); /* æ˜ã‚‹ã‚ã®åŠé€æ˜èƒŒæ™¯ */
    border-radius: 12px;                   /* ã‚«ãƒ¼ãƒ‰é¢¨ã®ä¸¸ã¿ */
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); /* è»½ã„å½± */
    display: flex;
    flex-wrap: wrap;    /* è¤‡æ•°è¡Œã«æŠ˜ã‚Šè¿”ã—å¯èƒ½ */
    gap: 4px;           /* å­è¦ç´ é–“ã®éš™é–“ */
  }

  #ui button {
    font-size: 16px;
    padding: 10px 14px;
    margin: 0;                           /* gap ã‚’ä½¿ã†ã®ã§ margin ã¯ä¸è¦ */
    border: none;                        /* æ ç·šã‚’æ¶ˆã—ã¦ã‚·ãƒ³ãƒ—ãƒ«ã« */
    border-radius: 6px;                  /* å°‘ã—ä¸¸ã¿ */
    background: linear-gradient(135deg, #8b4513, #a0522d); /* èŒ¶è‰²ç³»ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ */
    color: #fff;                         /* ç™½æ–‡å­— */
    cursor: pointer;                     /* ã‚«ãƒ¼ã‚½ãƒ« */
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);/* è»½ã„å½± */
    transition: transform 0.1s, box-shadow 0.1s;
  }

  #ui button:hover {
    transform: translateY(-2px);         /* æµ®ãä¸ŠãŒã‚‹ */
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  }

  #ui button:active {
    transform: translateY(0);            /* æˆ»ã‚‹ */
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }

  #rotationStatus {
    width: 100%;                         /* å…¨å¹…ã§è¡¨ç¤º */
    font-size: 16px;
    margin-top: 4px;
    color: #333;                         /* èª­ã¿ã‚„ã™ã„æ¿ƒã„ã‚°ãƒ¬ãƒ¼ */
  }

  /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆPCãªã©å¤§ãã„ç”»é¢ç”¨ï¼‰ */
  #previewCanvas {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 150px;
    height: 150px;
    border: 1px solid #ccc;
  }

  / * ã‚¹ãƒãƒ›ãªã©ç”»é¢ãŒç‹­ã„ã¨ã */
  @media (max-width: 600px) {
    #previewCanvas {
      width: 80px;
      height: 80px;
    }
  }

</style>
</head>
<body>

<canvas id="mainCanvas"></canvas>
<canvas id="previewCanvas"></canvas>

<div id="ui">
  <button id="addMode">è¿½åŠ </button>
  <button id="removeMode">å‰Šé™¤</button>
  <button id="rotateX">Xå›è»¢</button>
  <button id="rotateY">Yå›è»¢</button>
  <button id="rotateZ">Zå›è»¢</button>
  <div id="rotationStatus">å›è»¢çŠ¶æ…‹: X=0Â°, Y=0Â°, Z=0Â°</div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.175.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.175.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

let rotateX = 0, rotateY = 0, rotateZ = 0;
let mode = "add";
const blocks = [];
let currentModel, hitboxModel;

const allModels = {}; // è¦‹ã›ã‹ã‘ã®å›è»¢ç”¨ãƒ¢ãƒ‡ãƒ«ã‚’ä¿å­˜

const mainCanvas = document.getElementById("mainCanvas");
const renderer = new THREE.WebGLRenderer({ canvas: mainCanvas });
renderer.setSize(window.innerWidth, window.innerHeight);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xfaf3e0);
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(5,5,5);
camera.lookAt(0, 0, 0);
const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0,0,0);
controls.update();

renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // ã‚½ãƒ•ãƒˆã§è‡ªç„¶ãªå½±

scene.add(new THREE.DirectionalLight(0xffffff, 10).position.set(5,5,5));
scene.add(new THREE.AmbientLight(0xffffff, 1));

const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(5, 10, 5);
dirLight.castShadow = true;
dirLight.intensity = 1.5;

// å½±ã®ç¯„å›²ã‚„è§£åƒåº¦ã®èª¿æ•´ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
dirLight.shadow.mapSize.width = 1024;
dirLight.shadow.mapSize.height = 1024;
dirLight.shadow.camera.left = -5;
dirLight.shadow.camera.right = 5;
dirLight.shadow.camera.top = 5;
dirLight.shadow.camera.bottom = -5;
dirLight.shadow.camera.near = 1;
dirLight.shadow.camera.far = 10;

scene.add(dirLight);



// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
const previewCanvas = document.getElementById("previewCanvas");
const previewRenderer = new THREE.WebGLRenderer({ canvas: previewCanvas, alpha: true });
previewRenderer.setSize(150,150);

const previewScene = new THREE.Scene();
const previewCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
previewCamera.position.set(1.5,1.5,1.5);
previewCamera.lookAt(-0.1,0.3,0);

// âœ ç’°å¢ƒå…‰ï¼ˆã‚ã‚Œã°è¿½åŠ ï¼‰
const previewAmbient = new THREE.AmbientLight(0xffffff, 0.8);
previewScene.add(previewAmbient);

// âœ DirectionalLightï¼ˆå½±ã‚ã‚Šï¼‰
const previewLight = new THREE.DirectionalLight(0xffffff, 1);
previewLight.position.set(2, 2, 2);
previewLight.castShadow = true;

// å½±ã®è¨­å®š
previewLight.shadow.mapSize.width = 512;
previewLight.shadow.mapSize.height = 512;
previewLight.shadow.camera.left = -2;
previewLight.shadow.camera.right = 2;
previewLight.shadow.camera.top = 2;
previewLight.shadow.camera.bottom = -2;
previewLight.shadow.camera.near = 1;
previewLight.shadow.camera.far = 3;

previewScene.add(previewLight);
previewScene.add(new THREE.DirectionalLight(0xffffff,10).position.set(2,2,2));

let previewObject;

function updateRotationStatus() {
  document.getElementById("rotationStatus").textContent =
    `å›è»¢çŠ¶æ…‹: X=${rotateX}Â°, Y=${rotateY}Â°, Z=${rotateZ}Â°`;
}

// ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿
document.getElementById("addMode").addEventListener("click", ()=>{ mode="add"; });
document.getElementById("removeMode").addEventListener("click", ()=>{ mode="remove"; });

// å›è»¢
document.getElementById("rotateX").addEventListener("click", ()=>{
  rotateX = (rotateX+90)%360;
  rotateY = 0; rotateZ=0; // ä»–ã®è»¸ã‚’0ã«ãƒªã‚»ãƒƒãƒˆ
  updateModelByRotation();
});
document.getElementById("rotateY").addEventListener("click", ()=>{
  rotateY = (rotateY+90)%360;
  rotateX = 0; rotateZ=0;
  updateModelByRotation();
});
document.getElementById("rotateZ").addEventListener("click", ()=>{
  rotateZ = (rotateZ+90)%360;
  rotateX = 0; rotateY=0;
  updateModelByRotation();
});

function updateModelByRotation(){
  updateRotationStatus();

  let key = "";
  if(rotateX) key=`model_x_${rotateX}`;
  else if(rotateY) key=`model_y_${rotateY}`;
  else if(rotateZ) key=`model_z_${rotateZ}`;
  else key="model_x_0"; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ

  currentModel = allModels[key];

  // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚‚æ›´æ–°
  if(previewObject) previewScene.remove(previewObject);
  previewObject = currentModel.clone();
  previewScene.add(previewObject);
}

// ãƒ­ãƒ¼ãƒ€ãƒ¼
const loader = new GLTFLoader();
let modelsLoaded = 0;

// 12ç¨®é¡èª­ã¿è¾¼ã¿
const files = [
  "model_x_0","model_x_90","model_x_180","model_x_270",
  "model_y_0","model_y_90","model_y_180","model_y_270",
  "model_z_0","model_z_90","model_z_180","model_z_270"
];

files.forEach(file=>{
  loader.load(file+'.glb', (gltf)=>{
    const sceneModel = gltf.scene;
    sceneModel.traverse((child)=>{
      if(child.isMesh){
        child.castShadow = true;   // å½±ã‚’è½ã¨ã™
        child.receiveShadow = true; // å½±ã‚’å—ã‘ã‚‹
      }
    });
    allModels[file]=sceneModel;
    modelsLoaded++;
    initIfReady();
  });
});

// åˆ¤å®šç”¨ãƒ¢ãƒ‡ãƒ«box
loader.load('modelbox.glb', (gltf) => {
  hitboxModel = gltf.scene;
  hitboxModel.traverse((child)=>{
    if(child.isMesh){
      child.material.transparent = true;
      child.material.opacity = 0.01;
      child.material.color = new THREE.Color(0x00ff00);
    }
  });
  modelsLoaded++;
  initIfReady();
});


// å…¨éƒ¨èª­ã¿è¾¼ã¿çµ‚ã‚ã£ãŸã‚‰åˆæœŸé…ç½®
function initIfReady(){
  if(modelsLoaded === files.length+1){
    currentModel = allModels["model_x_0"];
    previewObject = currentModel.clone();
    previewObject.position.set(0, 0, 0);
    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã§å½±ã‚’æœ‰åŠ¹åŒ–
    previewRenderer.shadowMap.enabled = true;
    previewRenderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ã‚·ãƒ¼ãƒ³ã«ç’°å¢ƒå…‰ã‚’è¿½åŠ 
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    previewScene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 5);
    dirLight.castShadow = true;

    // clone å¾Œã« traverse ã™ã‚‹éš›ã€new MeshStandardMaterial ã‚’ä½¿ã‚ãšã€
    // å…ƒã®ãƒãƒ†ãƒªã‚¢ãƒ«ã®ã¾ã¾ã«ã™ã‚‹ï¼ˆã‚‚ã—å¿…è¦ãªã‚‰è‰²ã ã‘å¤‰ãˆã‚‹ï¼‰
    previewObject.traverse((child)=>{
      if(child.isMesh){
        child.castShadow = true;
        child.receiveShadow = true;
      }
    });
    previewScene.add(previewObject);
    updateRotationStatus();


    // åˆæœŸé…ç½®
    for(let x=0; x<3; x++){
      for(let z=0; z<2; z++){
        const pos = new THREE.Vector3((x-1)*1, -0.5*1, (z-0.5)*1);

        const model = currentModel.clone();
        model.position.copy(pos);
        scene.add(model);

        const box = hitboxModel.clone();
        box.position.copy(pos);
        scene.add(box);

        blocks.push({model, hitbox: box});
      }
    }

    // ğŸ”§ ã‚«ãƒ¡ãƒ©ã¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®åˆæœŸè¨­å®šã‚’ã“ã“ã§ã¾ã¨ã‚ã¦
    camera.position.set(5, 6, 5);   // å¿…è¦ã«å¿œã˜ã¦é«˜ã•ã‚„è·é›¢ã‚’èª¿æ•´
    camera.lookAt(0, 0, 0);

    controls.target.set(0, 0, 0);   // å›è»¢ãƒ»ã‚ºãƒ¼ãƒ ã®ä¸­å¿ƒã‚’åŸç‚¹ã«
    controls.update();
  }
}

// Raycaster
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
mainCanvas.addEventListener("pointerdown",(e)=>{
  const rect = mainCanvas.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left)/rect.width)*2 -1;
  mouse.y = -((e.clientY - rect.top)/rect.height)*2 +1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(blocks.map(b=>b.hitbox), true);

  if(intersects.length>0){
    const hit = intersects[0].object.parent;
    const block = blocks.find(b=>b.hitbox===hit || b.hitbox===hit.parent);
    if(!block) return;

    if(mode==="add"){
      const normal = intersects[0].face.normal;
      addBlock(block.hitbox.position, normal);
    }else if(mode==="remove"){
      scene.remove(block.model);
      scene.remove(block.hitbox);
      blocks.splice(blocks.indexOf(block),1);
    }
  }
});

function addBlock(basePos, normal){
  const pos = basePos.clone().add(normal);

  const model = currentModel.clone();
  model.position.copy(pos);
  scene.add(model);

  const box = hitboxModel.clone();
  box.position.copy(pos);
  scene.add(box);

  blocks.push({model, hitbox: box});
}

// æç”»ãƒ«ãƒ¼ãƒ—
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene,camera);
  previewRenderer.render(previewScene,previewCamera);
}
animate();

</script>
</body>
</html>

