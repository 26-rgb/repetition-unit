<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GLBモデル回転プレビュー</title>
<style>
  body { margin: 0; overflow: hidden; }
  #ui {
    position: absolute;
    bottom: 5px;
    left: 5px;
    padding: 12px;
    font-size: 16px;
    background: rgba(255, 255, 255, 0.9); /* 明るめの半透明背景 */
    border-radius: 12px;                   /* カード風の丸み */
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); /* 軽い影 */
    display: flex;
    flex-wrap: wrap;    /* 複数行に折り返し可能 */
    gap: 4px;           /* 子要素間の隙間 */
  }

  #ui button {
    font-size: 16px;
    padding: 10px 14px;
    margin: 0;                           /* gap を使うので margin は不要 */
    border: none;                        /* 枠線を消してシンプルに */
    border-radius: 6px;                  /* 少し丸み */
    background: linear-gradient(135deg, #8b4513, #a0522d); /* 茶色系グラデーション */
    color: #fff;                         /* 白文字 */
    cursor: pointer;                     /* カーソル */
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);/* 軽い影 */
    transition: transform 0.1s, box-shadow 0.1s;
  }

  #ui button:hover {
    transform: translateY(-2px);         /* 浮き上がる */
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  }

  #ui button:active {
    transform: translateY(0);            /* 戻る */
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }

  #rotationStatus {
    width: 100%;                         /* 全幅で表示 */
    font-size: 16px;
    margin-top: 4px;
    color: #333;                         /* 読みやすい濃いグレー */
  }

  /* デフォルト（PCなど大きい画面用） */
  #previewCanvas {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 150px;
    height: 150px;
    border: 1px solid #ccc;
  }

  / * スマホなど画面が狭いとき */
  @media (max-width: 600px) {
    #previewCanvas {
      width: 80px;
      height: 80px;
    }
  }

</style>
</head>
<body>

<canvas id="mainCanvas"></canvas>
<canvas id="previewCanvas"></canvas>

<div id="ui">
  <button id="addMode">追加</button>
  <button id="removeMode">削除</button>
  <button id="rotateX">X回転</button>
  <button id="rotateY">Y回転</button>
  <button id="rotateZ">Z回転</button>
  <div id="rotationStatus">回転状態: X=0°, Y=0°, Z=0°</div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.175.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.175.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

let rotateX = 0, rotateY = 0, rotateZ = 0;
let mode = "add";
const blocks = [];
let currentModel, hitboxModel;

const allModels = {}; // 見せかけの回転用モデルを保存

const mainCanvas = document.getElementById("mainCanvas");
const renderer = new THREE.WebGLRenderer({ canvas: mainCanvas });
renderer.setSize(window.innerWidth, window.innerHeight);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xfaf3e0);
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(5,5,5);
camera.lookAt(0, 0, 0);
const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0,0,0);
controls.update();

renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // ソフトで自然な影

scene.add(new THREE.DirectionalLight(0xffffff, 10).position.set(5,5,5));
scene.add(new THREE.AmbientLight(0xffffff, 1));

const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(5, 10, 5);
dirLight.castShadow = true;
dirLight.intensity = 1.5;

// 影の範囲や解像度の調整（必要に応じて）
dirLight.shadow.mapSize.width = 1024;
dirLight.shadow.mapSize.height = 1024;
dirLight.shadow.camera.left = -5;
dirLight.shadow.camera.right = 5;
dirLight.shadow.camera.top = 5;
dirLight.shadow.camera.bottom = -5;
dirLight.shadow.camera.near = 1;
dirLight.shadow.camera.far = 10;

scene.add(dirLight);



// プレビュー
const previewCanvas = document.getElementById("previewCanvas");
const previewRenderer = new THREE.WebGLRenderer({ canvas: previewCanvas, alpha: true });
previewRenderer.setSize(150,150);

const previewScene = new THREE.Scene();
const previewCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
previewCamera.position.set(1.5,1.5,1.5);
previewCamera.lookAt(-0.1,0.3,0);

// ✏ 環境光（あれば追加）
const previewAmbient = new THREE.AmbientLight(0xffffff, 0.8);
previewScene.add(previewAmbient);

// ✏ DirectionalLight（影あり）
const previewLight = new THREE.DirectionalLight(0xffffff, 1);
previewLight.position.set(2, 2, 2);
previewLight.castShadow = true;

// 影の設定
previewLight.shadow.mapSize.width = 512;
previewLight.shadow.mapSize.height = 512;
previewLight.shadow.camera.left = -2;
previewLight.shadow.camera.right = 2;
previewLight.shadow.camera.top = 2;
previewLight.shadow.camera.bottom = -2;
previewLight.shadow.camera.near = 1;
previewLight.shadow.camera.far = 3;

previewScene.add(previewLight);
previewScene.add(new THREE.DirectionalLight(0xffffff,10).position.set(2,2,2));

let previewObject;

function updateRotationStatus() {
  document.getElementById("rotationStatus").textContent =
    `回転状態: X=${rotateX}°, Y=${rotateY}°, Z=${rotateZ}°`;
}

// モード切替
document.getElementById("addMode").addEventListener("click", ()=>{ mode="add"; });
document.getElementById("removeMode").addEventListener("click", ()=>{ mode="remove"; });

// 回転
document.getElementById("rotateX").addEventListener("click", ()=>{
  rotateX = (rotateX+90)%360;
  rotateY = 0; rotateZ=0; // 他の軸を0にリセット
  updateModelByRotation();
});
document.getElementById("rotateY").addEventListener("click", ()=>{
  rotateY = (rotateY+90)%360;
  rotateX = 0; rotateZ=0;
  updateModelByRotation();
});
document.getElementById("rotateZ").addEventListener("click", ()=>{
  rotateZ = (rotateZ+90)%360;
  rotateX = 0; rotateY=0;
  updateModelByRotation();
});

function updateModelByRotation(){
  updateRotationStatus();

  let key = "";
  if(rotateX) key=`model_x_${rotateX}`;
  else if(rotateY) key=`model_y_${rotateY}`;
  else if(rotateZ) key=`model_z_${rotateZ}`;
  else key="model_x_0"; // デフォルト

  currentModel = allModels[key];

  // プレビューも更新
  if(previewObject) previewScene.remove(previewObject);
  previewObject = currentModel.clone();
  previewScene.add(previewObject);
}

// ローダー
const loader = new GLTFLoader();
let modelsLoaded = 0;

// 12種類読み込み
const files = [
  "model_x_0","model_x_90","model_x_180","model_x_270",
  "model_y_0","model_y_90","model_y_180","model_y_270",
  "model_z_0","model_z_90","model_z_180","model_z_270"
];

files.forEach(file=>{
  loader.load(file+'.glb', (gltf)=>{
    const sceneModel = gltf.scene;
    sceneModel.traverse((child)=>{
      if(child.isMesh){
        child.castShadow = true;   // 影を落とす
        child.receiveShadow = true; // 影を受ける
      }
    });
    allModels[file]=sceneModel;
    modelsLoaded++;
    initIfReady();
  });
});

// 判定用モデルbox
loader.load('modelbox.glb', (gltf) => {
  hitboxModel = gltf.scene;
  hitboxModel.traverse((child)=>{
    if(child.isMesh){
      child.material.transparent = true;
      child.material.opacity = 0.01;
      child.material.color = new THREE.Color(0x00ff00);
    }
  });
  modelsLoaded++;
  initIfReady();
});


// 全部読み込み終わったら初期配置
function initIfReady(){
  if(modelsLoaded === files.length+1){
    currentModel = allModels["model_x_0"];
    previewObject = currentModel.clone();
    previewObject.position.set(0, 0, 0);
    // プレビュー用レンダラーで影を有効化
    previewRenderer.shadowMap.enabled = true;
    previewRenderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // プレビュー用シーンに環境光を追加
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    previewScene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 5);
    dirLight.castShadow = true;

    // clone 後に traverse する際、new MeshStandardMaterial を使わず、
    // 元のマテリアルのままにする（もし必要なら色だけ変える）
    previewObject.traverse((child)=>{
      if(child.isMesh){
        child.castShadow = true;
        child.receiveShadow = true;
      }
    });
    previewScene.add(previewObject);
    updateRotationStatus();


    // 初期配置
    for(let x=0; x<3; x++){
      for(let z=0; z<2; z++){
        const pos = new THREE.Vector3((x-1)*1, -0.5*1, (z-0.5)*1);

        const model = currentModel.clone();
        model.position.copy(pos);
        scene.add(model);

        const box = hitboxModel.clone();
        box.position.copy(pos);
        scene.add(box);

        blocks.push({model, hitbox: box});
      }
    }

    // 🔧 カメラとコントロールの初期設定をここでまとめて
    camera.position.set(5, 6, 5);   // 必要に応じて高さや距離を調整
    camera.lookAt(0, 0, 0);

    controls.target.set(0, 0, 0);   // 回転・ズームの中心を原点に
    controls.update();
  }
}

// Raycaster
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
mainCanvas.addEventListener("pointerdown",(e)=>{
  const rect = mainCanvas.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left)/rect.width)*2 -1;
  mouse.y = -((e.clientY - rect.top)/rect.height)*2 +1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(blocks.map(b=>b.hitbox), true);

  if(intersects.length>0){
    const hit = intersects[0].object.parent;
    const block = blocks.find(b=>b.hitbox===hit || b.hitbox===hit.parent);
    if(!block) return;

    if(mode==="add"){
      const normal = intersects[0].face.normal;
      addBlock(block.hitbox.position, normal);
    }else if(mode==="remove"){
      scene.remove(block.model);
      scene.remove(block.hitbox);
      blocks.splice(blocks.indexOf(block),1);
    }
  }
});

function addBlock(basePos, normal){
  const pos = basePos.clone().add(normal);

  const model = currentModel.clone();
  model.position.copy(pos);
  scene.add(model);

  const box = hitboxModel.clone();
  box.position.copy(pos);
  scene.add(box);

  blocks.push({model, hitbox: box});
}

// 描画ループ
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene,camera);
  previewRenderer.render(previewScene,previewCamera);
}
animate();

</script>
</body>
</html>

